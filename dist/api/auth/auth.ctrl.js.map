{"version":3,"sources":["../../../src/api/auth/auth.ctrl.js"],"names":["register","ctx","request","body","email","password","username","schema","Joi","object","keys","string","required","min","max","validateResult","validate","error","status","type","message","details","User","findByEmail","existUser","localSignup","user","throw","login","verifyPassword","accessToken","cookie","set","httpOnly","expires","Date","now","socialCallback","state","cookies","redirect"],"mappings":"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","file":"auth.ctrl.js","sourcesContent":["import User from 'db/models/User';\nimport logger from 'lib/logger';\nimport generateToken from 'lib/generateToken';\nimport Joi from 'joi';\n\nexport const register = async ctx => {\n    const {\n        email,\n        password,\n        username\n    } = ctx.request.body;\n    \n    const schema = Joi.object().keys({\n        email : Joi.string().email().required(),\n        password : Joi.string().min(8).max(10).required(),\n        username : Joi.string().min(6).max(20).required()\n    });\n\n    let validateResult = schema.validate(ctx.request.body);\n\n    if( validateResult.error != null ) {\n        ctx.status = 422;\n        ctx.body = { \n            type : \"ValidateError\",\n            message : validateResult.error.details[0].message }\n        ;\n        return; \n    }\n    \n    \n    try {\n        const existUser = await User.findByEmail(email);\n        \n        if(!existUser){\n            const user = await User.localSignup({ email, password, username });\n            ctx.status = 200;\n        } else {\n            ctx.status = 409;\n            ctx.body = { message : \"Email is already exists!\" };\n        }\n        \n    } catch(e) {\n        ctx.throw(e,500);\n    }\n};\n\n\nexport const login = async ctx => {\n    const {\n        email, \n        password\n    } = ctx.request.body;\n\n    const schema = Joi.object().keys({\n        email : Joi.string().email().required(),\n        password : Joi.string().min(8).max(10).required()\n    });\n\n    let validateResult = schema.validate(ctx.request.body);\n\n    if( validateResult.error != null ) {\n        ctx.status = 422;\n        ctx.body = { \n            type : \"ValidateError\",\n            message : validateResult.error.details[0].message }\n        ;\n        return;\n    }\n    \n    \n    try {\n        const existUser = await User.findByEmail(email);\n        \n        if(!existUser) {\n            ctx.status = 403;\n            ctx.body = { message : \"User does not exists!\"};\n            return ;\n        }\n\n        if(!existUser.verifyPassword(password)){\n            ctx.status = 403;\n            ctx.body = { message : \"Password does not match!\"};\n            return ;\n        }\n\n        let accessToken = generateToken({ email : existUser.email });\n\n        ctx.cookie.set('accessToken',  accessToken, {\n            httpOnly : true,\n            expires: new Date((1000 * 60 * 60) + Date.now()) //1h\n        })\n\n    } catch(e) {\n        ctx.throw(e, 500);     \n    }\n};\n\n\nexport const socialCallback = ctx => {\n    const { email } = ctx.state.user;\n    let accessToken = generateToken({email});\n    ctx.cookies.set('accessToken', accessToken, {\n        httpOnly: true,\n        expires: new Date((1000 * 60 * 60) + Date.now()) //1h\n    });\n    ctx.redirect('/');\n}"]}